{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import random as rd\n",
    "def My_OX_Game():\n",
    "    P, C = 'X', 'O'\n",
    "    level, board, order, R = 0, np.full((3,3), '_'), [], {'C': 0, 'P': 0, 'draw': 0}\n",
    "    deco = '\\n' + '=' * 25 + '\\n'\n",
    "    welcome = ('\\nWelcome! Please choose game level\\n(type [ end ] to end at anytime)\\n' +\n",
    "                'type [ easy / mid / master ]\\n')\n",
    "    ask_next = '\\nWhere do you wanna put {0}?\\n(valid number range: 0,1,2 ex: 2, 2 )'\n",
    "    c_rep = \"I'm done! I put {0} at ({1}, {2})\\n\"\n",
    "    playend = 'Would you wanna play again?\\ntype [ play / end ]\\n'\n",
    "    \n",
    "    def Err_(res, msg): #invalid input\n",
    "        print(\"\\nSorry, invalid input: '\", res,\"' please type again!\")\n",
    "        return 'type [ {0} ]'.format(msg)\n",
    "    \n",
    "    def Winner_(row, col):  \n",
    "        h, v = set(board[row]), set(board.T[col])\n",
    "        d1, d2 = set(board.flat[[0,4,8]]), set(board.flat[[2,4,6]])\n",
    "        for x in [{P}, {C}]:  # someone won\n",
    "            if x in (h, v, d1, d2):\n",
    "                if x == {P}: #player won\n",
    "                    R['P'] += 1\n",
    "                    print('\\n ====Congrats! you won====\\n', board, deco)\n",
    "                else: # computer won\n",
    "                    R['C'] += 1\n",
    "                    print( '\\n =======Good  Game!=======\\n', board, deco) \n",
    "                order.append('end')\n",
    "                return playend\n",
    "        if '_' not in board:  # a draw\n",
    "            R['draw'] += 1\n",
    "            order.append('end')  \n",
    "            print( \"\\n =========A draw!=========\\n\", board, deco)\n",
    "            return playend\n",
    "        # keep playing\n",
    "        elif order[-1] == P:  # player's turn end \n",
    "            print(\"\\nYou put {0} at ({1}, {2})\\n\".format(P, row, col),\n",
    "                  board,\"\\n\\nnow it's my turn!\\n\")\n",
    "            return C_(board)\n",
    "        else: # computer's turn end\n",
    "            print(ask_next.format(P))\n",
    "            return 'type [ row, column ]'\n",
    "    \n",
    "    \n",
    "    def C_(board): # calculate the best position.... the most difficult part\n",
    "        order.append(C)\n",
    "        d1, d2 = board.flat[[0,4,8]], board.flat[[2,4,6]]\n",
    "        vacancy = set()\n",
    "        # test if anyone is about to connect in his next turn\n",
    "        for x in [C,P]:\n",
    "            line = []\n",
    "            for i in range(3): \n",
    "                if d1[i] == '_' and set(sorted(d1)[:2]) == {x}:\n",
    "                    line.append((i,i))\n",
    "                if d2[i] == '_' and set(sorted(d2)[:2]) == {x}:\n",
    "                    line.append((i, 2-i))\n",
    "                for j in range(3):\n",
    "                    if board[i,j] == '_':\n",
    "                        vacancy.add((i,j))\n",
    "                        if set(sorted(board[i])[:2]) == {x}:\n",
    "                            line.append((i,j))\n",
    "                    if board[j,i] == '_' and set(sorted(board.T[i])[:2]) == {x}:\n",
    "                        line.append((j,i))\n",
    "            if line: # some one is about to connect\n",
    "                row, col = rd.choice(line)\n",
    "                board[row, col] = C\n",
    "                print(c_rep.format(C, row, col), board)\n",
    "                return Winner_(row, col)\n",
    "        \n",
    "        # no one is about to connect\n",
    "        corner = {(0,0), (2,0), (0,2), (2,2)}\n",
    "        row, col = rd.choice(list(vacancy)) # default for not-included & easy\n",
    "        if corner & vacancy and level in ['mid', 'master']:\n",
    "            row, col = rd.choice(list(corner & vacancy))\n",
    "            if board[1,1] == '_':\n",
    "                row, col = rd.choice([(1, 1), (row, col)])\n",
    "            d = {0: [1, 3, 2], 2: [1, 5, 0], 6: [7, 3, 8], 8: [7, 5, 6]}\n",
    "            \n",
    "            '''\n",
    "            P _ _\n",
    "            _ C *\n",
    "            _ _ P\n",
    "            '''\n",
    "            d6 = list(filter(lambda x: ( # defend with 6 empty\n",
    "                set(board.flat[[ abs(x-4) - 1, 9 - abs(x-4) ]]) == {P} \n",
    "                and board[1,1] == C and len(vacancy) == 6), [1,3,5,7]))\n",
    "            \n",
    "            '''\n",
    "            _ ? _    _ P _\n",
    "            C C P    ? C ?\n",
    "            * ? _    * C _\n",
    "            '''\n",
    "            bsT_4 = list(filter(lambda x: ( # big slope Triangle with 4 available corner\n",
    "                (set(board.flat[[ 4, d[x][1] ]]) in ({C}, {P})\n",
    "                 and set(board.flat[[ x, 8 - x, 8 -d[x][2] ]]) == {'_'} )\n",
    "                or (set(board.flat[[ 4, d[x][0] ]]) in ({C}, {P})\n",
    "                    and set(board.flat[[ x, 8 - x, d[x][2] ]]) == {'_'} )), [0,2,6,8]))\n",
    "                      \n",
    "            '''\n",
    "            * C _\n",
    "            C ? ?\n",
    "            _ ? ?\n",
    "            \n",
    "            '''\n",
    "            sL_3 = list(filter(lambda x: ( # small L with 3 available corner\n",
    "                (set(board.flat[[ d[x][0], d[x][1] ]]) in ({C}, {P}) \n",
    "                and set(board.flat[[ x, d[x][2], 8 - d[x][2] ]]) == {'_'} )), [0,2,6,8]))\n",
    "            \n",
    "            '''\n",
    "            * C _   * _ C \n",
    "            _ ? ?   C ? ?\n",
    "            C ? ?   _ ? ?\n",
    "            '''\n",
    "            sL_2 = list(filter(lambda x: ( # small L with 2 available corner\n",
    "                (set(board.flat[[ d[x][2], d[x][1] ]]) in ({C}, {P})\n",
    "                 and set(board.flat[[ x, 8 - d[x][2], d[x][0] ]]) == {'_'} )\n",
    "                or (set(board.flat[[ 8 - d[x][2], d[x][0] ]]) in ({C}, {P})\n",
    "                    and set(board.flat[[ x, d[x][2], d[x][1] ]]) == {'_'} )), [0,2,6,8]))\n",
    "            \n",
    "            '''\n",
    "             C P _   P ? _\n",
    "             _ C ?   ? C P\n",
    "             * ? P   * _ C\n",
    "            '''\n",
    "            bsT_2 = list(filter(lambda x: ( # big slope Triangle with 2 available corner\n",
    "                (set(board.flat[[ 4, 8 - d[x][2] ]]) in ({C}, {P})\n",
    "                 and set(board.flat[[ x, 8 - x, d[x][1] ]]) == {'_'} )\n",
    "                or (set(board.flat[[ 4, d[x][2] ]]) in ({C}, {P})\n",
    "                    and set(board.flat[[ x, 8 - x, d[x][0] ]]) == {'_'} )), [0,2,6,8]))\n",
    "            \n",
    "            '''\n",
    "            ? ? C    C P C\n",
    "            ? _ P    _ _ ?\n",
    "            * _ C    * ? ?\n",
    "            '''\n",
    "            bsT_1  = list(filter(lambda x: ( # big slope Triangle with 1 available corner\n",
    "                (set(board.flat[[ 8 - x, 8 - d[x][2] ]]) in ({C}, {P})\n",
    "                 and set(board.flat[[ x, 4, d[x][1] ]]) == {'_'} )\n",
    "                or (set(board.flat[[ 8 - x, d[x][2] ]]) in ({C}, {P})\n",
    "                    and set(board.flat[[ x, 4, d[x][0] ]]) == {'_'} )), [0,2,6,8]))\n",
    "            \n",
    "            '''\n",
    "            C ? ?\n",
    "            _ P ?\n",
    "            * _ C\n",
    "            '''\n",
    "            bL_1 = list(filter(lambda x: ( # big L with 1 available corner\n",
    "                set(board.flat[[ d[x][2], 8 - d[x][2] ]]) == {C}\n",
    "                and set(board.flat[[ x, d[x][0], d[x][1] ]]) == {'_'} ), [0,2,6,8]))\n",
    "                      \n",
    "            if level == 'master' and (d6 or bsT_4 or sL_3 or sL_2):\n",
    "                x = 0\n",
    "                if d6:\n",
    "                    x = rd.choice(d6)\n",
    "                elif bsT_4:\n",
    "                    x = rd.choice(bsT_4)\n",
    "                elif sL_3:\n",
    "                    x = rd.choice(sL_3)    \n",
    "                else:\n",
    "                    x = rd.choice(sL_2)\n",
    "                row, col = x // 3, x % 3\n",
    "            \n",
    "            # master & mid\n",
    "            elif bsT_2 or bsT_1 or bL_1: \n",
    "                x = 0\n",
    "                if bsT_2:\n",
    "                    x = rd.choice(bsT_2)\n",
    "                elif bsT_1:\n",
    "                    x = rd.choice(bsT_1)    \n",
    "                else:\n",
    "                    x = rd.choice(bL_1)\n",
    "                row, col = x // 3, x % 3                         \n",
    "            elif len(corner & vacancy) == 3:\n",
    "                if board[1,1] == '_':\n",
    "                    row, col = 1, 1\n",
    "                else:\n",
    "                    x = list(corner - vacancy) \n",
    "                    row, col = 2 - x[0][0], 2 - x[0][1] \n",
    "        board[row, col] = C\n",
    "        print (c_rep.format(C, row, col), board)\n",
    "        return Winner_(row, col)\n",
    "\n",
    "\n",
    "    # main processing of player\n",
    "    print(welcome)\n",
    "    res = input().replace(' ','').lower()\n",
    "    while res != 'end': \n",
    "        res_s = res.split(',')\n",
    "        if not order: #choose level\n",
    "            if res in  ('easy', 'mid', 'master'):\n",
    "                level = res\n",
    "                order.append(level)\n",
    "                print('\\nYou choose [ {0} ] level'.format(level),\n",
    "                     '\\nWould you wanna start first?\\ntype [ y / n ]\\n')\n",
    "            else:\n",
    "                print(Err_(res, 'easy / mid / master')) \n",
    "        elif order == [level]: #game start\n",
    "            if res == 'y':\n",
    "                order.append(P)\n",
    "                print (ask_next.format(P),'\\ntype [ row, column ]')\n",
    "            elif res == 'n':\n",
    "                P, C = 'O', 'X'\n",
    "                order.append(C)\n",
    "                print(\"\\nTHX, you're a nice guy! I'll start first!\\n\\n\")\n",
    "                print(C_(board), '\\n')\n",
    "            else:\n",
    "                print( Err_(res, 'y / n') ) \n",
    "        elif (order[-1] !=  'end' and len(res_s)== 2   #player's turn\n",
    "               and set(res_s).issubset({'0','1','2'})): \n",
    "                row, col = int(res_s[0]), int(res_s[1])\n",
    "                if board[row, col] == '_':\n",
    "                    board[row, col] = P\n",
    "                    order.append(P)\n",
    "                    print(Winner_(row, col))   \n",
    "                else: # valid input but it's occupied\n",
    "                    print( '\\nSorry, {0},{1} is occupied!'.format(row, col),\n",
    "                          'please type again!\\ntype [ row, column ]\\n')\n",
    "        else: \n",
    "            if order[-1] == 'end':  # game over\n",
    "                if res.lower() == 'play': # play again\n",
    "                    board, order = np.full((3,3), '_'), []\n",
    "                    P, C = 'X', 'O'\n",
    "                    print(welcome)\n",
    "                else: \n",
    "                    print( Err_(res, 'play, end'))\n",
    "            else:\n",
    "                print( Err_(res, 'row, column') )  \n",
    "        res = input()\n",
    "    \n",
    "    result = '\\ntotal: {0}\\nPlayer: {1} %\\nComputer: {2} %\\nDraw: {3} %'\n",
    "    if sum(R.values()):\n",
    "        s = sum(R.values())\n",
    "        print(result.format(s), round(100 * R['P'] / s, 2), \n",
    "                           round(100 * R['C'] / s, 2),\n",
    "                           round(100 * R['draw'] / s, 2)))\n",
    "    print(deco, \" End the game\\n THX for playing MyGame!!!\", deco) #end game\n",
    "    R['P'], R['C'], R['draw'] = 0, 0, 0\n",
    "    return ''"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
